Tristan Bailey
CS446
PA1
Part 2 Q's

Question 1:
	System calls are effectivly the bridge between a process and the system's underlying operating system. They allow the process to get information or perform operations that can only be accessed/performed when in kernal mode. Examples include changing files and modifications to the file directory. In our code we implement the following system calls: read, write, open, close, fork, chdir, exit, wait, kill and print(which is just a write).
Question 2:
	In execvp the first parameter must be a strign representing a new process image file, (our file argument), then the second parameter must be a list of strings that starts with the previously decribed file argument, containt various argument sfor the new process, and is terminated in the NULL pointer. I tuses the global enviorn variable In excve the first parameter must be iether a binary executable or a script, the second parameter is a list containting string that are the [rpgrams CLAs, finally the last parameter is the enviorment that the program will execute in and is terminated by the nullptr. These two function are similar in how they both give the user access to a wide variety of different processes/programs they can use to assist their own program. Aditionally,both programs are similar in what they take as thier first parameters and these first two parameters have similar restrictions.  The key difference is that execve allow syou to specify the calling enviorment for the new process/program while execvp uses the defual global enviorn variable. Finall, execve uses a pathname to find the program to execute meanwhile excvp uses the file name and then finds the pathname to the program.
Question 3:
	Alternatives to the kill system call include the exit call, or the return operation. The problems with these alternativ emethods for exiting the program are dependent upon where the code is in exicution. If exit is called in a sub process, then it exits only that subprocess, the rest of the program keeps running. This is undesireable for our use case. As we would have to keep track of where we are in the program, and somehow filter this call upstream so the overall program terminates. By using Kill it allows us to not have to keep track of where we are in the program or what process we are in, and remember to filter the command up. Instead we can simply call kill on the parent process, and it ends the whole program. Another benefit of kill is it is a widely implemented process on many OS, but some of these other alternatives may not be present on the other OS as a viable means of ending the program.
Question 4:
	One possible improvment that could really help the shell to bbe even more efficient and functional is to allow for a parsing system for multiple commands. One example of this is to let the use make a director and chang to that directory using syntax like the following: mkdir && cd <some name>. This would avoid two system calls (one for each command) in getting inpu from the user, but it would also improve the user experience. This would rais ea complexity in sub process timing, as you don't whant to change to the directory before it is made. One functionality not implemented in the exe but uimplemented in this system is how it will split the arguments and call the command on each argument. This improves parallelity when running the child processes, but could run into isses if there are commands that chain to gether several necessary argumentss for one execution of the command. As such improved recognition of these states and improve parsing for these states. The last point that should be adressed is the inefficent funftionality of parts of this program. There are several function calls that update several of thier paramter value for use in the caller and are not complex functions. This adds complexity, as the developer has to remember all the pointers and updates, but it also makes the program less efficien from a runtime persepctive as tfor each of these class the stack must be called. This is slower than just keeping it within one functionality. SO the program could benefit from reduction of the number of simple functions.
